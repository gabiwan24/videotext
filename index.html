<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kamera-Texterkennung</title>
    <!-- Tailwind CSS für das Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- p5.js Bibliothek -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <!-- Tesseract.js Bibliothek für OCR -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <!-- Matter.js Physik-Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #111827;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        @keyframes blink {
            50% { opacity: 0.5; }
        }
        .blinking {
            animation: blink 1s linear infinite;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans">

    <div id="canvas-container"></div>

    <div class="absolute bottom-4 left-4 flex flex-col gap-3 w-48">
        <div>
            <label for="visibility-slider" class="block text-xs font-medium text-white/70">Sichtbarkeit Video: <span id="visibility-value" class="font-bold">10</span>%</label>
            <input id="visibility-slider" type="range" min="0" max="100" value="10" class="w-full h-1.5 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        </div>
        <div>
            <label for="confidence-slider" class="block text-xs font-medium text-white/70">Genauigkeitsschwelle: <span id="confidence-value" class="font-bold">50</span>%</label>
            <input id="confidence-slider" type="range" min="0" max="100" value="50" class="w-full h-1.5 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        </div>
    </div>
    
    <div class="absolute bottom-4 right-4">
        <div id="scan-indicator" class="w-3 h-3 bg-red-500 rounded-full hidden"></div>
    </div>
    
    <div id="status-overlay" class="absolute inset-0 flex justify-center items-center pointer-events-none">
         <div class="bg-gray-900/70 backdrop-blur-sm p-4 rounded-xl shadow-lg">
            <p id="status-text" class="text-white text-center">Initialisiere Kamera...</p>
         </div>
    </div>


    <script>
        // Matter.js Module
        const { Engine, World, Bodies, Body, Composite } = Matter;

        let capture;
        let p5Canvas;
        let videoReady = false;
        let isRecognizing = false;
        
        let drawX, drawY, drawW, drawH;
        
        let physicsLetters = [];
        let worker;

        // Physik-Welt
        let engine;
        let world;
        
        let backgroundAlpha = 230;
        let confidenceThreshold = 50;
        const OVERLAP_TOLERANCE = 20;

        // UI Elemente
        const statusText = document.getElementById('status-text');
        const statusOverlay = document.getElementById('status-overlay');
        const scanIndicator = document.getElementById('scan-indicator');
        const visibilitySlider = document.getElementById('visibility-slider');
        const visibilityValue = document.getElementById('visibility-value');
        const confidenceSlider = document.getElementById('confidence-slider');
        const confidenceValue = document.getElementById('confidence-value');

        async function initializeTesseract() {
            if (!videoReady) {
                setTimeout(initializeTesseract, 100);
                return;
            }
            statusText.textContent = "Initialisiere Texterkennung...";
            worker = await Tesseract.createWorker('deu', 1);
            statusText.textContent = "Bereit. Halte Text vor die Kamera.";
            setTimeout(() => { statusOverlay.style.display = 'none'; }, 2000);
            setInterval(performRecognition, 1500);
        }

        function setup() {
            const canvasContainer = document.getElementById('canvas-container');
            p5Canvas = createCanvas(windowWidth, windowHeight);
            p5Canvas.parent('canvas-container');
            pixelDensity(1);
            
            engine = Engine.create();
            world = engine.world;
            engine.world.gravity.y = 0;

            capture = createCapture(VIDEO, () => {
                videoReady = true;
                statusText.textContent = "Kamera bereit.";
                calculateLayout();
                initializeTesseract();
            });
            capture.size(640, 480);
            capture.hide();

            visibilitySlider.addEventListener('input', (e) => {
                const visibility = parseInt(e.target.value);
                visibilityValue.textContent = visibility;
                backgroundAlpha = map(visibility, 0, 100, 255, 0);
            });
            
            confidenceSlider.addEventListener('input', (e) => {
                confidenceThreshold = parseInt(e.target.value);
                confidenceValue.textContent = confidenceThreshold;
            });
        }
        
        function calculateLayout() {
            if (!capture || capture.width === 0) return;
            const videoRatio = capture.width / capture.height;
            const windowRatio = width / height;

            if (windowRatio > videoRatio) {
                drawH = height;
                drawW = height * videoRatio;
                drawX = (width - drawW) / 2;
                drawY = 0;
            } else {
                drawW = width;
                drawH = width / videoRatio;
                drawX = 0;
                drawY = (height - drawH) / 2;
            }
        }

        function draw() {
            background(0);

            if(videoReady) {
                image(capture, drawX, drawY, drawW, drawH);
            }

            background(0, backgroundAlpha);

            Engine.update(engine);

            for (let i = physicsLetters.length - 1; i >= 0; i--) {
                const letter = physicsLetters[i];
                const pos = letter.body.position;
                const angle = letter.body.angle;

                if (pos.y > height + 50) {
                    Composite.remove(world, letter.body);
                    physicsLetters.splice(i, 1);
                    continue;
                }

                push();
                translate(pos.x, pos.y);
                rotate(angle);
                fill(255);
                noStroke();
                textFont('Arial');
                textAlign(CENTER, CENTER);
                textSize(letter.h * 0.8);
                text(letter.text, 0, 0);
                pop();
            }
        }

        function triggerFall() {
            if (physicsLetters.length === 0) return;
            
            engine.world.gravity.y = 1;
            for (const letter of physicsLetters) {
                Body.setStatic(letter.body, false);
                const randomRotation = random(-0.15, 0.15);
                Body.setAngularVelocity(letter.body, randomRotation);
            }
        }

        function keyPressed() {
            if (keyCode === ENTER) {
                triggerFall();
            }
        }

        async function performRecognition() {
            if (isRecognizing || !videoReady || !worker) return;

            isRecognizing = true;
            scanIndicator.classList.remove('hidden');
            scanIndicator.classList.add('blinking');
            
            const ocrGraphics = createGraphics(capture.width, capture.height);
            ocrGraphics.image(capture, 0, 0, capture.width, capture.height);
            ocrGraphics.filter(THRESHOLD);
            const imageData = ocrGraphics.elt.toDataURL();

            try {
                const { data } = await worker.recognize(imageData);
                
                for (const word of data.words) {
                    const wordText = word.text.trim();
                    const cleanWord = wordText.replace(/[^a-zA-ZäöüÄÖÜß]/g, '');
                    const hasVowel = /[aeiouäöü]/i.test(cleanWord);

                    if (word.confidence > confidenceThreshold && cleanWord.length >= 3 && hasVowel) {
                        const { x0, y0, x1, y1 } = word.bbox;
                        const w = x1 - x0;
                        const h = y1 - y0;

                        const letterWidth = w / wordText.length;
                        let lastLetterRightEdge = null; // Verfolgt die rechte Kante des letzten Buchstabens im Wort

                        for (let i = 0; i < wordText.length; i++) {
                            const letterText = wordText[i];
                            const letterX = x0 + i * letterWidth;
                            
                            let displayX = map(letterX + letterWidth / 2, 0, capture.width, drawX, drawW + drawX);
                            const displayY = map(y0 + h / 2, 0, capture.height, drawY, drawH + drawY);
                            const displayW = map(letterWidth, 0, capture.width, 0, drawW);
                            const displayH = map(h, 0, capture.height, 0, drawH);
                            
                            // NEU: Kerning-Logik, um Überlappung innerhalb eines Wortes zu verhindern
                            if (lastLetterRightEdge !== null && (displayX - displayW / 2 < lastLetterRightEdge)) {
                                displayX = lastLetterRightEdge + displayW / 2;
                            }

                            let isTooClose = false;
                            for(const existingLetter of physicsLetters) {
                                if (!existingLetter.body) continue;
                                const d = dist(displayX, displayY, existingLetter.body.position.x, existingLetter.body.position.y);
                                if (d < OVERLAP_TOLERANCE) {
                                    isTooClose = true;
                                    break;
                                }
                            }
                            if (isTooClose) {
                                // Bricht die Verarbeitung des gesamten Wortes ab, wenn ein Buchstabe zu nah ist
                                lastLetterRightEdge = null; // Reset für das nächste Wort
                                break;
                            }

                            const density = map(displayH, 10, 100, 0.001, 0.005, true);

                            const body = Bodies.rectangle(displayX, displayY, displayW, displayH, { 
                                isStatic: true,
                                restitution: 0.5,
                                friction: 0.1,
                                density: density
                            });
                            
                            physicsLetters.push({
                                text: letterText,
                                w: displayW,
                                h: displayH,
                                body: body
                            });
                            World.add(world, body);
                            
                            // Aktualisiert die Position der rechten Kante für den nächsten Buchstaben
                            lastLetterRightEdge = displayX + displayW / 2;
                        }

                        if (wordText.toUpperCase() === "RESET") {
                            triggerFall();
                        }
                    }
                }

            } catch (error) {
                console.error(error);
            } finally {
                isRecognizing = false;
                scanIndicator.classList.add('hidden');
                scanIndicator.classList.remove('blinking');
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            calculateLayout();
            World.clear(world);
            physicsLetters = []; 
            engine.world.gravity.y = 0;
        }
    </script>
</body>
</html>
