<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kamera-Texterkennung (Echtzeit-Overlay)</title>
    <title>Kamera-Texterkennung</title>
    <!-- Tailwind CSS für das Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- p5.js Bibliothek -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <!-- Tesseract.js Bibliothek für OCR -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <!-- Matter.js Physik-Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        html, body {
            margin: 0;
@@ -29,85 +31,99 @@
            justify-content: center;
            align-items: center;
        }
        .ui-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: none; 
        @keyframes blink {
            50% { opacity: 0.5; }
        }
        .ui-element {
            pointer-events: auto;
        .blinking {
            animation: blink 1s linear infinite;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans">

    <div id="canvas-container"></div>

    <div class="ui-overlay p-4 sm:p-6 flex justify-center items-end">
        <div class="ui-element w-full max-w-xl bg-gray-900/70 backdrop-blur-sm p-4 rounded-xl shadow-lg">
              <div class="flex flex-col items-center justify-center gap-4">
                   <!-- Slider für die Sichtbarkeit des Videobilds -->
                  <div class="w-full">
                      <label for="visibility-slider" class="block text-sm font-medium mb-2 text-center text-white">Sichtbarkeit Video: <span id="visibility-value" class="font-bold">10</span>%</label>
                      <input id="visibility-slider" type="range" min="0" max="100" value="10" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                  </div>
                  <div id="status-container" class="w-full h-8 text-center text-sm text-gray-300">
                      <p id="status-text">Initialisiere Kamera...</p>
                      <div id="progress-bar-container" class="w-full bg-gray-700 rounded-full h-2.5 mt-1 hidden">
                          <div id="progress-bar" class="bg-indigo-500 h-2.5 rounded-full" style="width: 0%"></div>
                      </div>
                  </div>
              </div>
    <div class="absolute bottom-4 left-4 flex flex-col gap-3 w-48">
        <div>
            <label for="visibility-slider" class="block text-xs font-medium text-white/70">Sichtbarkeit Video: <span id="visibility-value" class="font-bold">10</span>%</label>
            <input id="visibility-slider" type="range" min="0" max="100" value="10" class="w-full h-1.5 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        </div>
        <div>
            <label for="confidence-slider" class="block text-xs font-medium text-white/70">Genauigkeitsschwelle: <span id="confidence-value" class="font-bold">50</span>%</label>
            <input id="confidence-slider" type="range" min="0" max="100" value="50" class="w-full h-1.5 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        </div>
    </div>
    
    <div class="absolute bottom-4 right-4">
        <div id="scan-indicator" class="w-3 h-3 bg-red-500 rounded-full hidden"></div>
    </div>
    
    <div id="status-overlay" class="absolute inset-0 flex justify-center items-center pointer-events-none">
         <div class="bg-gray-900/70 backdrop-blur-sm p-4 rounded-xl shadow-lg">
            <p id="status-text" class="text-white text-center">Initialisiere Kamera...</p>
         </div>
    </div>


    <script>
        // Matter.js Module
        const { Engine, World, Bodies, Body, Composite } = Matter;

        let capture;
        let p5Canvas;
        let videoReady = false;
        let isRecognizing = false;

        // NEU: Variablen für das responsive Layout
        let drawX, drawY, drawW, drawH;

        let recognizedWords = [];
        let physicsLetters = [];
        let worker;

        // Physik-Welt
        let engine;
        let world;

        let backgroundAlpha = 230; // Entspricht 10% Sichtbarkeit
        let backgroundAlpha = 230;
        let confidenceThreshold = 50;
        const OVERLAP_TOLERANCE = 20;

        // UI Elemente
        const statusText = document.getElementById('status-text');
        const progressBarContainer = document.getElementById('progress-bar-container');
        const progressBar = document.getElementById('progress-bar');
        const statusOverlay = document.getElementById('status-overlay');
        const scanIndicator = document.getElementById('scan-indicator');
        const visibilitySlider = document.getElementById('visibility-slider');
        const visibilityValue = document.getElementById('visibility-value');
        const confidenceSlider = document.getElementById('confidence-slider');
        const confidenceValue = document.getElementById('confidence-value');

        async function initializeTesseract() {
            if (!videoReady) {
                setTimeout(initializeTesseract, 100);
                return;
            }
            statusText.textContent = "Initialisiere Texterkennung...";
            worker = await Tesseract.createWorker('deu', 1, {
                logger: updateStatus,
            });
            worker = await Tesseract.createWorker('deu', 1);
            statusText.textContent = "Bereit. Halte Text vor die Kamera.";
            setTimeout(() => { statusOverlay.style.display = 'none'; }, 2000);
            setInterval(performRecognition, 1500);
        }

        function setup() {
            const canvasContainer = document.getElementById('canvas-container');
            // GEÄNDERT: Canvas füllt jetzt das ganze Fenster
            p5Canvas = createCanvas(windowWidth, windowHeight);
            p5Canvas.parent('canvas-container');
            pixelDensity(1);

            engine = Engine.create();
            world = engine.world;
            engine.world.gravity.y = 0;

            capture = createCapture(VIDEO, () => {
                videoReady = true;
                statusText.textContent = "Kamera bereit.";
                // NEU: Layout nach dem Start der Kamera berechnen
                calculateLayout();
                initializeTesseract();
            });
            // Fordert eine Standardauflösung an, die dann skaliert wird
            capture.size(640, 480);
            capture.hide();

@@ -116,9 +132,13 @@
                visibilityValue.textContent = visibility;
                backgroundAlpha = map(visibility, 0, 100, 255, 0);
            });
            
            confidenceSlider.addEventListener('input', (e) => {
                confidenceThreshold = parseInt(e.target.value);
                confidenceValue.textContent = confidenceThreshold;
            });
        }

        // NEU: Funktion zur Berechnung des responsiven Layouts
        function calculateLayout() {
            if (!capture || capture.width === 0) return;
            const videoRatio = capture.width / capture.height;
@@ -138,93 +158,157 @@
        }

        function draw() {
            // Zuerst einen komplett schwarzen Hintergrund zeichnen
            background(0);

            if(videoReady) {
                // GEÄNDERT: Das Kamerabild wird jetzt ungespiegelt und responsiv gezeichnet
                image(capture, drawX, drawY, drawW, drawH);
            }

            // Dann den halbtransparenten schwarzen Hintergrund darüber legen
            background(0, backgroundAlpha);

            if (recognizedWords.length > 0) {
                for (const word of recognizedWords) {
                    // GEÄNDERT: Die Position wird jetzt auf das responsive Layout umgerechnet
                    const displayX = map(word.x, 0, capture.width, drawX, drawX + drawW);
                    const displayY = map(word.y, 0, capture.height, drawY, drawY + drawH);
                    const displayH = map(word.h, 0, capture.height, 0, drawH);
                    
                    fill(255);
                    noStroke();
                    textFont('Arial');
                    textAlign(LEFT, TOP);
                    textSize(displayH * 0.8);
                    text(word.text, displayX, displayY);
            Engine.update(engine);

            for (let i = physicsLetters.length - 1; i >= 0; i--) {
                const letter = physicsLetters[i];
                const pos = letter.body.position;
                const angle = letter.body.angle;

                if (pos.y > height + 50) {
                    Composite.remove(world, letter.body);
                    physicsLetters.splice(i, 1);
                    continue;
                }

                push();
                translate(pos.x, pos.y);
                rotate(angle);
                fill(255);
                noStroke();
                textFont('Arial');
                textAlign(CENTER, CENTER);
                textSize(letter.h * 0.8);
                text(letter.text, 0, 0);
                pop();
            }
        }
        
        function updateStatus(message) {
            statusText.textContent = message.status;
            if (message.status === 'recognizing text') {
                progressBarContainer.classList.remove('hidden');
                const progress = (message.progress * 100).toFixed(2);
                progressBar.style.width = `${progress}%`;
            } else {
                 progressBarContainer.classList.add('hidden');

        function triggerFall() {
            if (physicsLetters.length === 0) return;
            
            engine.world.gravity.y = 1;
            for (const letter of physicsLetters) {
                Body.setStatic(letter.body, false);
                const randomRotation = random(-0.15, 0.15);
                Body.setAngularVelocity(letter.body, randomRotation);
            }
        }

        function keyPressed() {
            if (keyCode === ENTER) {
                triggerFall();
            }
        }

        async function performRecognition() {
            if (isRecognizing || !videoReady || !worker) return;

            isRecognizing = true;
            scanIndicator.classList.remove('hidden');
            scanIndicator.classList.add('blinking');

            // Die Analyse erfolgt weiterhin auf dem Originalbild der Kamera
            const imageData = capture.canvas.toDataURL();
            const ocrGraphics = createGraphics(capture.width, capture.height);
            ocrGraphics.image(capture, 0, 0, capture.width, capture.height);
            ocrGraphics.filter(THRESHOLD);
            const imageData = ocrGraphics.elt.toDataURL();

            try {
                const { data } = await worker.recognize(imageData);
                const newWords = [];
                
                for (const word of data.words) {
                    if (word.confidence > 60 && word.text.length > 3) {
                    const wordText = word.text.trim();
                    const cleanWord = wordText.replace(/[^a-zA-ZäöüÄÖÜß]/g, '');
                    const hasVowel = /[aeiouäöü]/i.test(cleanWord);

                    if (word.confidence > confidenceThreshold && cleanWord.length >= 3 && hasVowel) {
                        const { x0, y0, x1, y1 } = word.bbox;
                        const w = x1 - x0;
                        const h = y1 - y0;
                        
                        newWords.push({
                            text: word.text,
                            x: x0,
                            y: y0,
                            w: w,
                            h: h,
                        });

                        const letterWidth = w / wordText.length;
                        let lastLetterRightEdge = null; // Verfolgt die rechte Kante des letzten Buchstabens im Wort

                        for (let i = 0; i < wordText.length; i++) {
                            const letterText = wordText[i];
                            const letterX = x0 + i * letterWidth;
                            
                            let displayX = map(letterX + letterWidth / 2, 0, capture.width, drawX, drawW + drawX);
                            const displayY = map(y0 + h / 2, 0, capture.height, drawY, drawH + drawY);
                            const displayW = map(letterWidth, 0, capture.width, 0, drawW);
                            const displayH = map(h, 0, capture.height, 0, drawH);
                            
                            // NEU: Kerning-Logik, um Überlappung innerhalb eines Wortes zu verhindern
                            if (lastLetterRightEdge !== null && (displayX - displayW / 2 < lastLetterRightEdge)) {
                                displayX = lastLetterRightEdge + displayW / 2;
                            }

                            let isTooClose = false;
                            for(const existingLetter of physicsLetters) {
                                if (!existingLetter.body) continue;
                                const d = dist(displayX, displayY, existingLetter.body.position.x, existingLetter.body.position.y);
                                if (d < OVERLAP_TOLERANCE) {
                                    isTooClose = true;
                                    break;
                                }
                            }
                            if (isTooClose) {
                                // Bricht die Verarbeitung des gesamten Wortes ab, wenn ein Buchstabe zu nah ist
                                lastLetterRightEdge = null; // Reset für das nächste Wort
                                break;
                            }

                            const density = map(displayH, 10, 100, 0.001, 0.005, true);

                            const body = Bodies.rectangle(displayX, displayY, displayW, displayH, { 
                                isStatic: true,
                                restitution: 0.5,
                                friction: 0.1,
                                density: density
                            });
                            
                            physicsLetters.push({
                                text: letterText,
                                w: displayW,
                                h: displayH,
                                body: body
                            });
                            World.add(world, body);
                            
                            // Aktualisiert die Position der rechten Kante für den nächsten Buchstaben
                            lastLetterRightEdge = displayX + displayW / 2;
                        }

                        if (wordText.toUpperCase() === "RESET") {
                            triggerFall();
                        }
                    }
                }
                
                recognizedWords = recognizedWords.concat(newWords);

                statusText.textContent = ` ${recognizedWords.length} Wörter insgesamt gefunden. Scanne erneut...`;

            } catch (error) {
                console.error(error);
                statusText.textContent = "Ein Fehler ist aufgetreten.";
            } finally {
                isRecognizing = false;
                progressBarContainer.classList.add('hidden');
                scanIndicator.classList.add('hidden');
                scanIndicator.classList.remove('blinking');
            }
        }

        // GEÄNDERT: Funktion zur Anpassung bei Fenstergrößenänderung
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            calculateLayout();
            // Optional: Erkannte Wörter löschen, da ihre Positionen nicht mehr stimmen
            recognizedWords = []; 
            World.clear(world);
            physicsLetters = []; 
            engine.world.gravity.y = 0;
        }
    </script>
</body>
</html>
